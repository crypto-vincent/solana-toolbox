import { PublicKey } from '@solana/web3.js';
import { ToolboxIdlProgram } from '../src/ToolboxIdlProgram';

it('run', () => {
  // Create an IDL on the fly
  const idlProgram = ToolboxIdlProgram.tryParse({
    accounts: {
      BytemuckAccount: {
        discriminator: [],
        type: 'BytemuckContainer',
      },
    },
    types: {
      BytemuckContainer: {
        serialization: 'bytemuck',
        repr: 'c',
        fields: [
          { name: 'bytemuck_struct_c', type: 'BytemuckStructC' },
          { name: 'bytemuck_enum_c', type: 'BytemuckEnumC' },
          { name: 'bytemuck_enum_u8', type: 'BytemuckEnumU8' },
          { name: 'bytemuck_discriminant_c', type: 'BytemuckDiscriminantC' },
          { name: 'bytemuck_discriminant_u8', type: 'BytemuckDiscriminantU8' },
          { name: 'bytemuck_never', variants: [] },
          { name: 'bytemuck_field', type: 'u8' },
        ],
      },
      BytemuckStructC: {
        repr: 'c',
        fields: [
          { name: 'field1', type: 'u16' },
          { name: 'field2', type: 'pubkey' },
          { name: 'field3', type: 'u64' },
          { name: 'field4', type: 'u8' },
          { name: 'field5', fields: ['u8', 'u32'] },
        ],
      },
      BytemuckEnumC: {
        repr: 'c',
        variants: [
          { name: 'Case0', fields: [] },
          { name: 'Case1', fields: ['u16'] },
          { name: 'Case2', fields: ['pubkey'] },
          { name: 'Case3', fields: ['u64'] },
          { name: 'Case4', fields: ['u8'] },
          { name: 'Case5', fields: ['u32'] },
        ],
      },
      BytemuckEnumU8: {
        repr: 'rust',
        variants: [
          { name: 'Case0', fields: [] },
          { name: 'Case1', fields: ['u16'] },
          { name: 'Case2', fields: ['pubkey'] },
          { name: 'Case3', fields: ['u64'] },
          { name: 'Case4', fields: ['u8'] },
          { name: 'Case5', fields: ['u32'] },
        ],
      },
      BytemuckDiscriminantC: {
        repr: 'c',
        variants: [
          { name: 'CaseA', fields: [] },
          { name: 'CaseB', fields: [] },
          { name: 'CaseC', fields: [] },
        ],
      },
      BytemuckDiscriminantU8: {
        repr: 'rust',
        variants: [
          { name: 'CaseA', fields: [] },
          { name: 'CaseB', fields: [] },
          { name: 'CaseC', fields: [] },
        ],
      },
    },
  });
  // Choose the instruction
  const idlAccount = idlProgram.accounts.get('BytemuckAccount')!;
  // Bytemuck constants
  const keyF2 = new PublicKey([
    0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
    0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
    0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
  ]);
  const keyC2 = new PublicKey([
    0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2,
    0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2,
    0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2,
  ]);
  // Define dummy JSON data
  const bytemuckStructC = {
    field1: 0xf1f1,
    field2: keyF2.toBase58(),
    field3: 0xf3f3f3f3f3f3f3f3n.toString(),
    field4: 0xf4,
    field5: [0xf5, 0xf5f5f5f5],
  };
  // Generate cases datas
  const cases = [
    {
      name: 'Case0',
      data: Buffer.from([
        0xf1, 0xf1, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3,
        0xf4, 0xaa, 0xaa, 0xaa, 0xf5, 0xaa, 0xaa, 0xaa, 0xf5, 0xf5, 0xf5, 0xf5,
        0xaa, 0xaa, 0xaa, 0xaa, 0x00, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x00, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0x00, 0xaa, 0xaa, 0xaa, 0x00, 0xd0, 0xaa, 0xaa,
      ]),
      state: {
        bytemuck_struct_c: bytemuckStructC,
        bytemuck_enum_c: 'Case0',
        bytemuck_enum_u8: 'Case0',
        bytemuck_discriminant_c: 'CaseA',
        bytemuck_discriminant_u8: 'CaseA',
        bytemuck_never: null,
        bytemuck_field: 0xd0,
      },
    },
    {
      name: 'Case1',
      data: Buffer.from([
        0xf1, 0xf1, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3,
        0xf4, 0xaa, 0xaa, 0xaa, 0xf5, 0xaa, 0xaa, 0xaa, 0xf5, 0xf5, 0xf5, 0xf5,
        0xaa, 0xaa, 0xaa, 0xaa, 0x01, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xc1, 0xc1, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x01, 0xaa, 0xc1, 0xc1,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0x01, 0xaa, 0xaa, 0xaa, 0x01, 0xd1, 0xaa, 0xaa,
      ]),
      state: {
        bytemuck_struct_c: bytemuckStructC,
        bytemuck_enum_c: { Case1: [0xc1c1] },
        bytemuck_enum_u8: { Case1: [0xc1c1] },
        bytemuck_discriminant_c: 'CaseB',
        bytemuck_discriminant_u8: 'CaseB',
        bytemuck_never: null,
        bytemuck_field: 0xd1,
      },
    },
    {
      name: 'Case2',
      data: Buffer.from([
        0xf1, 0xf1, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3,
        0xf4, 0xaa, 0xaa, 0xaa, 0xf5, 0xaa, 0xaa, 0xaa, 0xf5, 0xf5, 0xf5, 0xf5,
        0xaa, 0xaa, 0xaa, 0xaa, 0x02, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2,
        0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2,
        0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0x02, 0xc2, 0xc2, 0xc2,
        0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2,
        0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2,
        0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0x02, 0xaa, 0xaa, 0xaa, 0x02, 0xd2, 0xaa, 0xaa,
      ]),
      state: {
        bytemuck_struct_c: bytemuckStructC,
        bytemuck_enum_c: { Case2: [keyC2.toBase58()] },
        bytemuck_enum_u8: { Case2: [keyC2.toBase58()] },
        bytemuck_discriminant_c: 'CaseC',
        bytemuck_discriminant_u8: 'CaseC',
        bytemuck_never: null,
        bytemuck_field: 0xd2,
      },
    },
    {
      name: 'Case3',
      data: Buffer.from([
        0xf1, 0xf1, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3,
        0xf4, 0xaa, 0xaa, 0xaa, 0xf5, 0xaa, 0xaa, 0xaa, 0xf5, 0xf5, 0xf5, 0xf5,
        0xaa, 0xaa, 0xaa, 0xaa, 0x03, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x03, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0x00, 0xaa, 0xaa, 0xaa, 0x00, 0xd3, 0xaa, 0xaa,
      ]),
      state: {
        bytemuck_struct_c: bytemuckStructC,
        bytemuck_enum_c: { Case3: [0xc3c3c3c3c3c3c3c3n.toString()] },
        bytemuck_enum_u8: { Case3: [0xc3c3c3c3c3c3c3c3n.toString()] },
        bytemuck_discriminant_c: 'CaseA',
        bytemuck_discriminant_u8: 'CaseA',
        bytemuck_never: null,
        bytemuck_field: 0xd3,
      },
    },
    {
      name: 'Case4',
      data: Buffer.from([
        0xf1, 0xf1, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3,
        0xf4, 0xaa, 0xaa, 0xaa, 0xf5, 0xaa, 0xaa, 0xaa, 0xf5, 0xf5, 0xf5, 0xf5,
        0xaa, 0xaa, 0xaa, 0xaa, 0x04, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xc4, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x04, 0xc4, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0x01, 0xaa, 0xaa, 0xaa, 0x01, 0xd4, 0xaa, 0xaa,
      ]),
      state: {
        bytemuck_struct_c: bytemuckStructC,
        bytemuck_enum_c: { Case4: [0xc4] },
        bytemuck_enum_u8: { Case4: [0xc4] },
        bytemuck_discriminant_c: 'CaseB',
        bytemuck_discriminant_u8: 'CaseB',
        bytemuck_never: null,
        bytemuck_field: 0xd4,
      },
    },
    {
      name: 'Case5',
      data: Buffer.from([
        0xf1, 0xf1, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3,
        0xf4, 0xaa, 0xaa, 0xaa, 0xf5, 0xaa, 0xaa, 0xaa, 0xf5, 0xf5, 0xf5, 0xf5,
        0xaa, 0xaa, 0xaa, 0xaa, 0x05, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xc5, 0xc5, 0xc5, 0xc5, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x05, 0xaa, 0xaa, 0xaa,
        0xc5, 0xc5, 0xc5, 0xc5, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0x02, 0xaa, 0xaa, 0xaa, 0x02, 0xd5, 0xaa, 0xaa,
      ]),
      state: {
        bytemuck_struct_c: bytemuckStructC,
        bytemuck_enum_c: { Case5: [0xc5c5c5c5] },
        bytemuck_enum_u8: { Case5: [0xc5c5c5c5] },
        bytemuck_discriminant_c: 'CaseC',
        bytemuck_discriminant_u8: 'CaseC',
        bytemuck_never: null,
        bytemuck_field: 0xd5,
      },
    },
  ];
  // Actually assert the correctness of the results
  for (const testCase of cases) {
    const computedData = idlAccount.encode(testCase.state);
    // dumpData(testCase.name + ':computedData', computedData);
    // dumpData(testCase.name + ':expectedData', testCase.data);
    expect(idlAccount.decode(testCase.data)).toStrictEqual(testCase.state);
    expect(idlAccount.decode(computedData)).toStrictEqual(testCase.state);
  }
});

/*
function dumpData(title: string, buffer: Buffer) {
  const lines = [];
  const lineCount = (buffer.length + 1) / 16;
  for (const line = 0; line < lineCount; line++) {
    const words = [];
    for (const word = 0; word < 4; word++) {
      const bytes = [];
      for (const byte = 0; byte < 4; byte++) {
        const offset = line * 16 + word * 4 + byte;
        if (offset < buffer.length) {
          const value = buffer.readUint8(offset);
          bytes.push('0x' + value.toString(16).padStart(2, '0'));
        }
      }
      words.push(bytes.join(' '));
    }
    lines.push(words.join('  '));
  }
  console.log(title, '\n', lines.join('\n'));
}
*/
